# Introduction to Reverse Engineering

---

## What is Forward Engineering?

Before understanding **reverse engineering**, we first need to understand **forward engineering**, which is the standard software development process that most of you are already familiar with.

Forward engineering is the traditional process of moving from **high-level abstractions and requirements** to the **final physical implementation** of a system.

In simpler terms, it is the act of **building** something from scratch:

1. **Idea / Requirements** -- You define what the software should do.
2. **Design** -- You plan the architecture, choose data structures, algorithms, etc.
3. **Implementation** -- You write source code in a high-level language (C, Python, Java, etc.).
4. **Compilation / Build** -- The compiler transforms your source code into machine code (a binary executable).
5. **Deployment** -- The final binary runs on the target machine.

```
[Idea] --> [Design] --> [Source Code] --> [Compiler] --> [Binary / Executable]
```

The key takeaway: in forward engineering, **you start with the knowledge** (source code, design documents) and produce a working product.

---

## What is Reverse Engineering?

Reverse engineering is the exact **opposite** of forward engineering. Instead of building a system from a design, you start with the **finished product** (a compiled binary, a hardware device, a protocol) and work **backwards** to understand how it was designed and how it functions.

```
[Binary / Executable] --> [Disassembly / Decompilation] --> [Understanding the Logic] --> [Source-level Knowledge]
```

Formally, reverse engineering is the process of **analyzing a system to identify its components and their interrelationships**, and to create representations of the system at a higher level of abstraction.

You receive a closed box and your job is to figure out what is inside, how it works, and why it works that way -- **without** having access to the original blueprints.

---

## Goals and Applications of Reverse Engineering

Reverse engineering is not just an academic exercise. It serves critical real-world purposes across multiple domains:

### In Cybersecurity
- **Malware Analysis** -- Security researchers reverse engineer viruses, trojans, ransomware, and other malicious software to understand their behavior, identify indicators of compromise (IOCs), and develop signatures for detection.
- **Vulnerability Research** -- Reverse engineering proprietary software to discover security flaws (buffer overflows, logic bugs, etc.) before malicious actors do.
- **CTF Competitions** -- Reverse engineering challenges are a staple category in Capture The Flag competitions, where participants must analyze binaries to extract hidden flags.
- **Exploit Development** -- Understanding how a program works internally is a prerequisite to developing reliable exploits.

### In Software Engineering
- **Interoperability** -- Understanding undocumented file formats or network protocols to build compatible software (e.g., the Samba project reverse-engineered SMB/CIFS to provide Windows file sharing on Linux).
- **Legacy System Migration** -- When source code is lost, reverse engineering the existing binary is often the only way to understand and recreate the system.
- **Competitive Analysis** -- Studying how a competitor's product works to understand their approach (within legal boundaries).

### In Software Cracking and Piracy (The Illegal Side)

It is important to acknowledge that reverse engineering has historically been heavily associated with **software piracy**. While these activities are illegal and unethical in a commercial context, understanding them is relevant because they rely on the exact same skills taught in this workshop, and many professional reverse engineers originally learned through these avenues:

- **Software Cracks / Patches** -- A "crack" is a modified version of a program (or a small patch applied to it) that removes or bypasses its copy protection, license checks, or trial limitations. The reverse engineer analyzes the binary to find the branch instruction that checks whether a license is valid, and either patches the conditional jump (e.g., changing a `jne` to `je`, or `nop`-ing out the check entirely) or modifies the data the check relies on. The result is a binary that behaves as if it were fully licensed.

- **Keygens (Key Generators)** -- A keygen is a standalone program that generates valid license keys for a piece of software. To build one, the reverse engineer must fully understand the key validation algorithm embedded in the target software -- what mathematical operations it performs on the input key, what checksums or hashes it verifies, what format constraints it enforces. Once the algorithm is understood, the reverse engineer reimplements it (or its inverse) in a separate program that can produce any number of valid keys on demand. This requires a deeper level of understanding than a simple crack, because the entire validation logic must be reconstructed, not just bypassed.

- **Crackmes and Keygenmes** -- These are legal, educational counterparts to real-world cracks and keygens. A **crackme** is a small program deliberately designed to be cracked -- it implements some form of protection (password check, serial validation, anti-debugging) and challenges the reverse engineer to bypass it. A **keygenme** goes one step further: simply patching the binary is not considered a valid solution; the challenge is to write a keygen that produces valid keys accepted by the original, unmodified program. These are widely shared on platforms like [crackmes.one](https://crackmes.one/) and serve as the primary training ground for reverse engineering skills.

- **Game Cracks and Trainers** -- Games employ various forms of DRM (Digital Rights Management) such as Denuvo, VMProtect, or custom always-online checks. Cracking groups reverse engineer these protection layers to remove them. "Trainers" are a related concept: small tools that modify a game's memory at runtime to enable cheats (infinite health, unlimited currency, etc.) by locating and overwriting the relevant variables in memory. This is essentially applied dynamic analysis.

> **Note:** This workshop teaches reverse engineering strictly for educational purposes, security research, and CTF competitions. Cracking commercial software is illegal under laws such as the DMCA (Digital Millennium Copyright Act) and similar legislation worldwide. The skills are the same, but the application matters.

### In Hardware and Embedded Systems
- **Firmware Analysis** -- Extracting and analyzing firmware from IoT devices, routers, and embedded systems to audit their security.
- **Hardware Cloning / Repair** -- Understanding circuit designs to repair or reproduce discontinued hardware.

---

## Types of Reverse Engineering

Reverse engineering can be broadly divided into two fundamental approaches: **Static Analysis** and **Dynamic Analysis**. Each has its own tools, methodology, strengths, and weaknesses. In practice, a reverse engineer uses **both** in combination.

---

### 1. Static Analysis

Static analysis is the process of examining a binary **without executing it**. You analyze the code on disk, reading through the disassembly or decompiled output to understand what the program does.

Think of it as reading a book -- you study the text (instructions) carefully, tracing the logic in your head or on paper, without ever "running" the story.

#### Tools for Static Analysis

| **Tool** | **Description** | **Cost** |
|---|---|---|
| [Ghidra](https://ghidra-sre.org/) | NSA's open-source reverse engineering suite with a powerful decompiler. The go-to free tool. | Free |
| [IDA Pro](https://hex-rays.com/ida-pro/) | The industry standard disassembler and decompiler. Extremely powerful, widely used in the industry. | Commercial (IDA Free available) |
| [Binary Ninja](https://binary.ninja/) | Modern disassembler with a clean UI and strong API for scripting. Offers a free cloud version. | Commercial (Cloud version free) |
| [Cutter](https://cutter.re/) | Open-source GUI frontend for the Rizin reverse engineering framework. | Free |
| `objdump` | Command-line disassembler bundled with GNU Binutils. Available on virtually any Linux system. | Free |
| `strings` | Extracts human-readable strings from binary files. Simple but surprisingly useful as a first step. | Free |
| `file` | Identifies the type and format of a file (ELF, PE, Mach-O, architecture, etc.). | Free |
| `readelf` / `nm` | Inspect ELF headers, sections, symbols, and other metadata of ELF binaries. | Free |

#### Methodology for Static Analysis

A structured approach to static analysis typically follows these steps:

1. **Reconnaissance** -- Run `file` to determine the binary type, architecture, and whether it is stripped. Run `strings` to extract readable text (error messages, URLs, hardcoded credentials, format strings). Run `nm` or `readelf` to inspect symbols if the binary is not stripped.

2. **Load into a Disassembler/Decompiler** -- Open the binary in Ghidra, IDA, or Binary Ninja. Let the tool perform its initial auto-analysis.

3. **Identify Key Functions** -- Locate `main()` or the entry point. Look for functions that reference interesting strings you found earlier. Identify calls to library functions like `strcmp`, `printf`, `scanf`, `memcpy`, `open`, `read`, `write`, `socket`, etc., as they reveal the program's behavior.

4. **Trace the Control Flow** -- Follow the execution path from the entry point. Understand conditional branches (`if/else`), loops (`for`, `while`), and function calls. Pay attention to how data is transformed (XOR, shifts, arithmetic).

5. **Rename and Annotate** -- As you understand what variables and functions do, rename them in your disassembler. This progressively makes the code more readable and is critical for complex binaries.

6. **Reconstruct the Logic** -- Piece together what the program does at a high level. If it is a crackme, identify where the password check happens and what the expected input is.

#### Advantages of Static Analysis
- Safe: the binary is never executed, so there is no risk from malicious code.
- Provides a complete view of the entire codebase.
- Can analyze code paths that are difficult to reach at runtime.

#### Limitations of Static Analysis
- Time-consuming for large or obfuscated binaries.
- Self-modifying code or packed binaries can hide their true logic until runtime.
- Requires strong knowledge of assembly language and calling conventions.

---

### 2. Dynamic Analysis

Dynamic analysis involves **running the binary** and observing its behavior in real time. You execute the program (usually in a controlled environment) and use debuggers and monitoring tools to inspect memory, registers, function calls, and program state as the code runs.

Think of it as watching a play being performed -- instead of reading the script, you watch the actors on stage and observe what actually happens.

#### Tools for Dynamic Analysis

| **Tool** | **Description** | **Cost** |
|---|---|---|
| [GDB](https://www.gnu.org/software/gdb/) | The GNU Debugger. The standard command-line debugger for Linux. Extremely powerful. | Free |
| [GDB + GEF](https://github.com/hugsy/gef) | GEF (GDB Enhanced Features) is a plugin that adds visual context (registers, stack, disassembly) to GDB. | Free |
| [GDB + pwndbg](https://github.com/pwndbg/pwndbg) | Another popular GDB enhancement, particularly favored for binary exploitation. | Free |
| [x64dbg](https://x64dbg.com/) | Open-source debugger for Windows executables (PE files). | Free |
| [strace](https://strace.io/) | Traces system calls made by a process (file access, network, process management, etc.). | Free |
| [ltrace](https://ltrace.org/) | Traces library calls made by a process (`printf`, `strcmp`, `malloc`, etc.). | Free |
| [Wireshark](https://www.wireshark.org/) | Network protocol analyzer. Useful when the binary communicates over the network. | Free |

#### Methodology for Dynamic Analysis

1. **Set Up a Safe Environment** -- If the binary is potentially malicious, run it inside a virtual machine or container. Never run untrusted binaries on your host system.

2. **Initial Run** -- Execute the binary normally to observe its basic behavior. What does it print? Does it ask for input? Does it create files or connect to a network?

3. **Trace System and Library Calls** -- Use `strace` to see what system calls the binary makes. Use `ltrace` to see what library functions it calls and with what arguments. This can immediately reveal passwords compared via `strcmp`, files opened, or network connections made.

4. **Set Breakpoints** -- Load the binary in GDB. Set breakpoints at key locations: `main`, functions that handle input, comparison functions like `strcmp`. Run the program and let it hit the breakpoint.

5. **Inspect State** -- When the program is paused at a breakpoint, examine registers, the stack, and memory contents. Step through the code instruction by instruction to observe how data is transformed.

6. **Manipulate Execution** -- Modify register values or memory contents to alter the program's behavior. Skip over checks, force branches, or inject your own data to test hypotheses about the program's logic.

#### Advantages of Dynamic Analysis
- Reveals the actual runtime behavior, including dynamically generated or decrypted code.
- Defeats most packing and obfuscation since the code must be decrypted to execute.
- `ltrace` and `strace` can give quick answers without deep analysis.
- Interactive: you can experiment and test hypotheses in real time.

#### Limitations of Dynamic Analysis
- Risk: you are executing potentially malicious code.
- You only see the code paths that are actually taken during your specific run.
- Anti-debugging techniques can detect and evade debuggers.
- Environment-dependent: the binary may behave differently on different systems.

---

### Static vs. Dynamic: A Summary

| **Aspect** | **Static Analysis** | **Dynamic Analysis** |
|---|---|---|
| **Execution** | Binary is NOT executed | Binary IS executed |
| **Safety** | Safe (no code runs) | Risk (code runs on your system) |
| **Coverage** | Can see all code paths | Only sees executed code paths |
| **Obfuscation** | Struggles with packing/encryption | Defeats packing (code decrypts at runtime) |
| **Speed** | Slower for understanding logic | Can get quick answers (e.g., `ltrace`) |
| **Tools** | Ghidra, IDA, objdump, strings | GDB, strace, ltrace, x64dbg |

In practice, **combine both**. Use static analysis to build a map of the binary, then use dynamic analysis to confirm your understanding and handle parts that are unclear from static analysis alone.

---

## Practical Example: Solving a Crackme

Now we will put everything into practice by solving a small crackme binary. A crackme is a program deliberately designed to be reverse engineered -- it typically asks for a password and rewards you with a flag if you provide the correct one.

The crackme used in this walkthrough is available here: [crackmes.one – crackme](https://crackmes.one/crackme/698a6214fb46458f1ef6cef5).

### Step 0: Initial Reconnaissance

The very first thing we do with any unknown binary is **identify what it is**. We use the `file` command for this.

```
$ file crackme
crackme: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked,
interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=a257f02aa427d3ad6559eef6d547657a5953f898,
for GNU/Linux 6.1.0, not stripped
```

Let us break down every piece of information this gives us:

| **Field** | **Value** | **Meaning** |
|---|---|---|
| **ELF** | Executable and Linkable Format | This is a Linux executable (not a Windows PE or macOS Mach-O). |
| **64-bit** | 64-bit address space | The binary uses 64-bit registers and instructions (not 32-bit). |
| **LSB** | Least Significant Byte first | The binary uses little-endian byte order. |
| **PIE executable** | Position-Independent Executable | The binary can be loaded at any address in memory (ASLR-compatible). |
| **x86-64** | AMD64 / Intel 64 architecture | The instruction set is x86-64 (the standard desktop/server architecture). |
| **dynamically linked** | Uses shared libraries | The binary relies on external libraries (like `libc`) loaded at runtime, as opposed to statically linked binaries that contain everything. |
| **interpreter /lib64/ld-linux-x86-64.so.2** | Dynamic linker path | This is the program that loads the shared libraries before `main()` runs. |
| **not stripped** | Symbol table is present | Function names (like `main`) and variable names are still in the binary. This makes reverse engineering significantly easier. A stripped binary would only show addresses. |

### Step 0.5: Inspecting the ELF Header with `readelf`

The `file` command gives us a summary, but `readelf` lets us dig deeper into the binary's internal structure. The `-h` flag displays the **ELF header**, which is the very first structure in the file and tells the operating system how to load and execute it.

```
$ readelf -h crackme
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1080
  Start of program headers:          64 (bytes into file)
  Start of section headers:          14416 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         14
  Size of section headers:           64 (bytes)
  Number of section headers:         30
  Section header string table index: 29
```

Let us break down the most important fields:

| **Field** | **Value** | **Meaning** |
|---|---|---|
| **Magic** | `7f 45 4c 46` | The first four bytes of every ELF file. `7f` followed by `ELF` in ASCII (`45 4c 46`). This is how the OS recognizes the file as an ELF binary. |
| **Class** | `ELF64` | 64-bit binary (as opposed to ELF32 for 32-bit). Determines register sizes and address widths. |
| **Data** | `2's complement, little endian` | Multi-byte values are stored with the least significant byte first. This is standard for x86/x86-64. |
| **OS/ABI** | `UNIX - System V` | The binary targets the standard Unix System V ABI, which is used by Linux, FreeBSD, and most Unix-like systems. |
| **Type** | `DYN` | A position-independent executable. `DYN` means the binary can be loaded at any memory address (required for ASLR). Other types include `EXEC` (fixed-address executable) and `REL` (relocatable object file, i.e., `.o` files). |
| **Machine** | `Advanced Micro Devices X86-64` | The target CPU architecture. This tells us we need an x86-64 disassembler and that we are dealing with the AMD64 instruction set. |
| **Entry point address** | `0x1080` | The virtual address where execution begins. This is **not** `main` -- it is `_start`, the C runtime startup code that eventually calls `main`. Because this is a PIE binary, `0x1080` is a relative offset, not an absolute address. |
| **Section headers** | `30 sections` | The binary is divided into 30 sections (`.text` for code, `.data` for initialized data, `.rodata` for read-only data, `.bss` for uninitialized data, `.symtab` for symbols, etc.). |
| **Program headers** | `14 segments` | Program headers describe how the OS should map the binary into memory at load time. They define which sections are loaded, at what permissions (read/write/execute), and where. |

The entry point address `0x1080` is particularly useful: if you are using a disassembler and want to trace execution from the very beginning, this is where to start. However, in practice, we almost always jump directly to `main` instead.

### Step 1: Extracting Strings

Before diving into disassembly, we extract readable strings from the binary. This is a fast way to get clues about what the program does.

```
$ strings crackme
```

Key strings we find (among others):

```
puts
__isoc23_scanf
printf
strcmp
You must enter a password to access this program!
wrong password, try again.
main.c
enc_msg
main
offset
flag
multiplier
key
```

**What we learn from this:**
- The program prints `"You must enter a password to access this program!"` and `"wrong password, try again."` -- so it is a password-checking program.
- It uses `scanf` for input and `strcmp` for comparison -- so it reads a string and compares it to something.
- There are interesting symbol names: `enc_msg`, `key`, `flag`, `multiplier`, `offset` -- suggesting the password and/or flag are encrypted/encoded in some way.
- The source file was called `main.c` and the binary is not stripped, so we have symbol names available.

---

### Step 2: Dynamic Analysis with GDB

We will solve the crackme **dynamically first** using GDB (GNU Debugger). The idea is to run the program under a debugger, set breakpoints at strategic locations, and inspect memory to extract the password.

#### 2.1: Launching GDB

```
$ gdb ./crackme
```

GDB will load the binary and display some version information. If you have a GDB enhancement plugin installed (such as **pwndbg** or **GEF**), you will see its banner as well. You will also see the message `(No debugging symbols found in ./crackme)` -- this is normal. It means the binary was compiled without debug info (`-g` flag), so we do not have source-level information. However, the binary is **not stripped**, so function and variable names are still available.

#### 2.2: Breaking at `main`

Our plan is to find the exact point where the program compares our input to the expected password. From `strings`, we know it uses `strcmp`. A naive first instinct might be to do `break strcmp`, but this is a **trap for beginners**: `strcmp` is a standard libc function that the system also uses internally. The dynamic linker (`ld-linux`) calls `strcmp` dozens of times during program startup to resolve library symbols (you would see backtraces full of `_dl_fixup`, `_dl_lookup_symbol_x`, `check_match`). Even **after** `main` starts, the very first call to any library function (like `puts` or `scanf`) triggers **lazy binding**, where the dynamic linker resolves that function's address at runtime -- and that resolution process internally calls `strcmp` again. You would have to type `continue` over and over through all of these irrelevant hits before reaching the one you actually care about.

The correct approach is to first break at `main` so we can inspect the disassembly and set a **precise** breakpoint at the exact instruction where our program calls `strcmp`:

```
pwndbg> break main
Breakpoint 1 at 0x11a1
```

The address `0x11a1` is a **relative offset** because this is a PIE binary. At runtime, the OS adds a random base address (ASLR), so the actual address will be different (e.g., `0x5555555551a1`).

#### 2.3: Running the Program

```
pwndbg> run
```

GDB starts the program and immediately pauses at our `main` breakpoint:

```
Breakpoint 1, 0x00005555555551a1 in main ()
```

pwndbg will display a rich view showing registers, the current disassembly, the stack, and the backtrace. At this point we are at the very beginning of `main`, before any of our program's logic has run.

#### 2.4: Disassembling `main` -- Full Walkthrough

Now we disassemble the `main` function to see all of its instructions:

```
pwndbg> disassemble main
```

GDB prints the full disassembly. Below is the complete output, broken into logical blocks with explanations for each.

---

**Block 1: Function Prologue and Stack Setup (main+0 to main+21)**

```asm
   0x1199 <+0>:     push   rbp
   0x119a <+1>:     mov    rbp,rsp
   0x119d <+4>:     sub    rsp,0x20
   0x11a1 <+8>:     mov    rax,QWORD PTR fs:0x28
   0x11aa <+17>:    mov    QWORD PTR [rbp-0x8],rax
   0x11ae <+21>:    xor    eax,eax
```

This is the standard function prologue that appears at the beginning of virtually every function:

- `push rbp` / `mov rbp, rsp` -- Saves the previous frame pointer and establishes a new **stack frame**. The frame pointer (`RBP`) serves as a fixed reference point for accessing local variables and function arguments.
- `sub rsp, 0x20` -- Allocates `0x20` (32) bytes on the stack for local variables.
- `mov rax, QWORD PTR fs:0x28` / `mov [rbp-0x8], rax` -- This is the **stack canary** (also called stack cookie). It loads a random value from the thread-local storage segment (`fs:0x28`) and stores it at the top of the local variable area. Before the function returns, it checks if this value was modified -- if it was, a buffer overflow occurred and the program calls `__stack_chk_fail` to abort. This is a compiler-inserted protection against stack-based buffer overflows.
- `xor eax, eax` -- Clears `EAX` to zero. This is an optimization -- `xor reg, reg` is the fastest way to set a register to zero.

**Local variable layout on the stack:**

| **Stack Location** | **Variable** | **Size** | **Purpose** |
|---|---|---|---|
| `[rbp-0x08]` | stack canary | 8 bytes | Buffer overflow protection |
| `[rbp-0x14]` | input buffer | 12 bytes | User's password input (char[12]) |
| `[rbp-0x18]` | loop counter `j` | 4 bytes | Counter for the flag decryption loop |
| `[rbp-0x1c]` | loop counter `i` | 4 bytes | Counter for the password decryption loop |
| `[rbp-0x1d]` | composite_key | 1 byte | Derived key for flag decryption |

---

**Block 2: Password Decryption Loop -- Initialization (main+23 to main+84)**

```asm
   0x11b0 <+23>:    mov    DWORD PTR [rbp-0x1c],0x0
   0x11b7 <+30>:    jmp    0x11e7 <main+78>
```

This sets the loop counter `i = 0` and jumps to the **loop condition check** at `main+78`. This is the standard pattern for a `for` loop -- the compiler places the condition check at the end so the loop body is only entered if the condition is true.

```asm
   ; --- Loop condition (jumped to first) ---
   0x11e7 <+78>:    mov    eax,DWORD PTR [rbp-0x1c]       ; eax = i
   0x11ea <+81>:    cmp    eax,0xa                         ; compare i with 10
   0x11ed <+84>:    jbe    0x11b9 <main+32>                ; if i <= 10, jump to loop body
```

The loop runs while `i <= 10` (i.e., `i` goes from 0 to 10, which is 11 iterations). This corresponds to the C code `for (int i = 0; i <= 10; i++)`.

---

**Block 3: Password Decryption Loop -- Body (main+32 to main+74)**

```asm
   ; --- Loop body ---
   0x11b9 <+32>:    mov    eax,DWORD PTR [rbp-0x1c]       ; eax = i
   0x11bc <+35>:    cdqe                                   ; sign-extend eax to rax (int -> long)
   0x11be <+37>:    lea    rdx,[rip+0x2e83]                ; rdx = address of enc_msg
   0x11c5 <+44>:    movzx  edx,BYTE PTR [rax+rdx*1]       ; edx = enc_msg[i] (one byte, zero-extended)
   0x11c9 <+48>:    movzx  eax,BYTE PTR [rip+0x2e84]      ; eax = key (one byte from address 0x4054)
   0x11d0 <+55>:    mov    ecx,edx                         ; ecx = enc_msg[i]
   0x11d2 <+57>:    xor    ecx,eax                         ; ecx = enc_msg[i] ^ key
   0x11d4 <+59>:    mov    eax,DWORD PTR [rbp-0x1c]       ; eax = i
   0x11d7 <+62>:    cdqe                                   ; sign-extend
   0x11d9 <+64>:    lea    rdx,[rip+0x2e68]                ; rdx = address of enc_msg
   0x11e0 <+71>:    mov    BYTE PTR [rax+rdx*1],cl         ; enc_msg[i] = ecx (the XOR result)
   0x11e3 <+74>:    add    DWORD PTR [rbp-0x1c],0x1        ; i++
```

This is the core decryption logic. For each byte of `enc_msg`, it:
1. Loads `enc_msg[i]`
2. Loads `key` (a single byte at address `0x4054`)
3. XORs them together: `enc_msg[i] = enc_msg[i] ^ key`
4. Stores the result back into `enc_msg[i]`
5. Increments `i`

In C, this entire block is simply: `enc_msg[i] = enc_msg[i] ^ key;`

This loop **decrypts the password in place**. After it finishes, `enc_msg` contains the plaintext password that will be compared against our input.

---

**Block 4: Composite Key Computation (main+86 to main+102)**

```asm
   0x11ef <+86>:    mov    eax,DWORD PTR [rip+0x2e4b]     ; eax = multiplier (at 0x4040)
   0x11f5 <+92>:    mov    edx,eax                         ; edx = multiplier
   0x11f7 <+94>:    mov    eax,DWORD PTR [rip+0x2e47]     ; eax = offset (at 0x4044)
   0x11fd <+100>:   xor    eax,edx                         ; eax = offset ^ multiplier
   0x11ff <+102>:   mov    BYTE PTR [rbp-0x1d],al          ; composite_key = (byte)(multiplier ^ offset)
```

This computes a derived key that will be used later to decrypt the flag: `composite_key = multiplier ^ offset`. Only the low byte (`al`) is kept and stored as a single byte at `[rbp-0x1d]`.

---

**Block 5: Print Prompt and Read First Input (main+105 to main+147)**

```asm
   0x1202 <+105>:   lea    rax,[rip+0xdff]                 ; rax = address of "You must enter a password..."
   0x1209 <+112>:   mov    rdi,rax                          ; rdi = first argument to puts
   0x120c <+115>:   call   0x1030 <puts@plt>                ; puts("You must enter a password...")

   0x1211 <+120>:   lea    rax,[rbp-0x14]                   ; rax = address of input buffer
   0x1215 <+124>:   lea    rdx,[rip+0xe1e]                  ; rdx = address of "%s" format string
   0x121c <+131>:   mov    rsi,rax                           ; rsi = input buffer (second arg)
   0x121f <+134>:   mov    rdi,rdx                           ; rdi = "%s" (first arg)
   0x1222 <+137>:   mov    eax,0x0                           ; eax = 0 (no floating-point args)
   0x1227 <+142>:   call   0x1060 <__isoc23_scanf@plt>       ; scanf("%s", input)

   0x122c <+147>:   jmp    0x125d <main+196>                 ; jump to the comparison
```

The program prints the prompt with `puts()`, then reads user input with `scanf("%s", input)`. After reading, it jumps directly to the comparison at `main+196`, skipping the "wrong password" block.

Notice the **vulnerability**: `scanf("%s", ...)` reads an unbounded string into a 12-byte buffer. In a binary exploitation context, this would be a buffer overflow. The stack canary at `[rbp-0x8]` is the compiler's defense against this.

---

**Block 6: Wrong Password -- Print Error and Read Again (main+149 to main+191)**

```asm
   0x122e <+149>:   lea    rax,[rip+0xe08]                  ; rax = address of "wrong password, try again.\n> "
   0x1235 <+156>:   mov    rdi,rax
   0x1238 <+159>:   mov    eax,0x0
   0x123d <+164>:   call   0x1050 <printf@plt>              ; printf("wrong password, try again.\n> ")

   0x1242 <+169>:   lea    rax,[rbp-0x14]                   ; rax = input buffer
   0x1246 <+173>:   lea    rdx,[rip+0xded]                  ; rdx = "%s"
   0x124d <+180>:   mov    rsi,rax
   0x1250 <+183>:   mov    rdi,rdx
   0x1253 <+186>:   mov    eax,0x0
   0x1258 <+191>:   call   0x1060 <__isoc23_scanf@plt>      ; scanf("%s", input)
```

This block is only reached when the password is wrong (we will see the jump that leads here in the next block). It prints an error message and reads new input, then falls through to the comparison again. This creates the **retry loop**.

---

**Block 7: Password Comparison (main+196 to main+220)**

```asm
   0x125d <+196>:   lea    rdx,[rip+0x2de4]                 ; rdx = address of enc_msg (now decrypted)
   0x1264 <+203>:   lea    rax,[rbp-0x14]                   ; rax = address of input buffer
   0x1268 <+207>:   mov    rsi,rdx                           ; rsi = enc_msg (second arg)
   0x126b <+210>:   mov    rdi,rax                           ; rdi = input (first arg)
   0x126e <+213>:   call   0x1070 <strcmp@plt>               ; strcmp(input, enc_msg)
   0x1273 <+218>:   test   eax,eax                           ; check return value
   0x1275 <+220>:   jne    0x122e <main+149>                 ; if not equal, jump to "wrong password"
```

This is the critical block. It calls `strcmp(input, enc_msg)`:
- `strcmp` returns `0` if the strings are equal, nonzero otherwise.
- `test eax, eax` sets the zero flag if `EAX` is zero.
- `jne` (jump if not equal) jumps back to the error message at `main+149` if the strings do not match.
- If the strings match, execution falls through to the flag decryption below.

**This is the instruction we will set our breakpoint on** -- `main+213` (`call strcmp@plt`) -- so we can inspect `RDI` and `RSI` right before the comparison happens.

---

**Block 8: Flag Decryption Loop (main+222 to main+287)**

```asm
   0x1277 <+222>:   mov    DWORD PTR [rbp-0x18],0x0        ; j = 0
   0x127e <+229>:   jmp    0x12b2 <main+281>                ; jump to loop condition

   ; --- Loop body ---
   0x1280 <+231>:   mov    eax,DWORD PTR [rbp-0x18]        ; eax = j
   0x1283 <+234>:   cdqe
   0x1285 <+236>:   lea    rdx,[rip+0x2dd4]                ; rdx = address of flag
   0x128c <+243>:   movzx  eax,BYTE PTR [rax+rdx*1]        ; eax = flag[j]
   0x1290 <+247>:   mov    edx,DWORD PTR [rbp-0x18]        ; edx = j
   0x1293 <+250>:   mov    ecx,edx                          ; ecx = j
   0x1295 <+252>:   movzx  edx,BYTE PTR [rbp-0x1d]         ; edx = composite_key
   0x1299 <+256>:   add    edx,ecx                          ; edx = composite_key + j
   0x129b <+258>:   xor    eax,edx                          ; eax = flag[j] ^ (composite_key + j)
   0x129d <+260>:   mov    ecx,eax                          ; ecx = result
   0x129f <+262>:   mov    eax,DWORD PTR [rbp-0x18]        ; eax = j
   0x12a2 <+265>:   cdqe
   0x12a4 <+267>:   lea    rdx,[rip+0x2db5]                ; rdx = address of flag
   0x12ab <+274>:   mov    BYTE PTR [rax+rdx*1],cl          ; flag[j] = result
   0x12ae <+277>:   add    DWORD PTR [rbp-0x18],0x1         ; j++

   ; --- Loop condition ---
   0x12b2 <+281>:   mov    eax,DWORD PTR [rbp-0x18]        ; eax = j
   0x12b5 <+284>:   cmp    eax,0x16                         ; compare j with 22
   0x12b8 <+287>:   jbe    0x1280 <main+231>                ; if j <= 22, continue loop
```

This loop only executes after the correct password is entered. It decrypts the flag in place:

`flag[j] = flag[j] ^ (composite_key + j)` for `j = 0` to `22` (23 characters).

The decryption key changes for each character because `j` is added to `composite_key`. This is a slightly more sophisticated variant of simple XOR -- it uses a **rolling key** that increments with each byte position.

---

**Block 9: Print Flag and Return (main+289 to main+330)**

```asm
   0x12ba <+289>:   lea    rax,[rip+0x2d9f]                ; rax = address of flag (now decrypted)
   0x12c1 <+296>:   mov    rdi,rax                          ; rdi = flag (argument to puts)
   0x12c4 <+299>:   call   0x1030 <puts@plt>               ; puts(flag) -- prints the flag

   0x12c9 <+304>:   mov    eax,0x0                          ; return value = 0
   0x12ce <+309>:   mov    rdx,QWORD PTR [rbp-0x8]         ; rdx = stored canary
   0x12d2 <+313>:   sub    rdx,QWORD PTR fs:0x28           ; compare with original canary
   0x12db <+322>:   je     0x12e2 <main+329>               ; if equal, canary is intact, safe to return
   0x12dd <+324>:   call   0x1040 <__stack_chk_fail@plt>   ; canary mismatch! abort (stack smashing detected)
   0x12e2 <+329>:   leave                                   ; restore rbp and rsp (reverse of prologue)
   0x12e3 <+330>:   ret                                     ; return to caller
```

After the flag is decrypted, `puts(flag)` prints it. Then the function epilogue runs:
1. The **stack canary check** -- it reloads the canary from `[rbp-0x8]` and compares it against the original value at `fs:0x28`. If they differ, someone overwrote the stack (buffer overflow) and `__stack_chk_fail` terminates the program.
2. `leave` -- equivalent to `mov rsp, rbp` / `pop rbp`, undoing the prologue.
3. `ret` -- pops the return address from the stack and jumps to it, returning control to the C runtime which called `main`.

---

**Summary of the program's flow as understood from the disassembly:**

```
main:
    1. Decrypt password:    for i in 0..10:  enc_msg[i] ^= key
    2. Compute flag key:    composite_key = multiplier ^ offset
    3. Print prompt
    4. Read input (scanf)
    5. Compare:             strcmp(input, enc_msg)
       |-- Not equal --> print "wrong password", read again, go to 5
       |-- Equal ------> continue
    6. Decrypt flag:        for j in 0..22:  flag[j] ^= (composite_key + j)
    7. Print flag (puts)
    8. Canary check, return
```

#### 2.5: Setting a Precise Breakpoint

We set a breakpoint at the exact address of that `call` instruction. We can use the `main+offset` syntax so we do not have to type the full address:

```
pwndbg> break *main+213
Breakpoint 2 at 0x55555555526e
```

The `*` before `main+213` tells GDB we are specifying a raw address (as opposed to a source line number). This breakpoint will **only** trigger when our program's own code reaches that instruction -- it completely avoids all the dynamic linker noise.

Now we continue execution:

```
pwndbg> continue
```

The program runs its initialization (decrypting the password with XOR in the first loop), then prints:

```
You must enter a password to access this program!
```

It is now waiting for our input. We type any string (e.g., `test`) and press Enter.

#### 2.6: Inspecting the `strcmp` Arguments

The program reads our input and reaches the `strcmp` call. GDB pauses at our breakpoint:

```
Breakpoint 2, 0x000055555555526e in main ()
```

At this point, the arguments to `strcmp` are already loaded into the registers. In the x86-64 System V calling convention, the first two function arguments are passed in `RDI` and `RSI`:

- `RDI` = first argument (our input)
- `RSI` = second argument (the expected password)

We examine them as strings using the `x/s` command (`x` = e**x**amine memory, `s` = as a **s**tring -- GDB reads from the address and prints characters until it hits a null byte):

```
pwndbg> x/s $rdi
0x7fffffffd26c: "test"

pwndbg> x/s $rsi
0x555555558048: "NAKED_SNAKE"
```

**We have the password: `NAKED_SNAKE`.**

Our input (`"test"`) is in `RDI`, and the decrypted expected password (`"NAKED_SNAKE"`) is in `RSI`. The program was about to call `strcmp("test", "NAKED_SNAKE")`, which would return a nonzero value (mismatch) and loop back to ask again. But we now know the correct answer.

#### 2.7: Verifying

We exit GDB (`quit`) and run the program normally with the correct password:

```
$ ./crackme
You must enter a password to access this program!
NAKED_SNAKE
FLAG{CIPHER_ENCRYPTION}
```

The program accepts our password, decrypts the flag, and prints it: **`FLAG{CIPHER_ENCRYPTION}`**.

#### Why Dynamic Analysis Worked So Well Here

The password was not stored in plaintext in the binary -- it was encrypted with XOR and only decrypted at runtime. But by breaking at `strcmp`, we caught the **decrypted** password in memory at the exact moment it was being compared. This is the power of dynamic analysis: it lets you observe data **after** it has been processed.

---

### Step 3: An Even Faster Dynamic Approach with `ltrace`

Before even opening GDB, we could have used `ltrace` to trace all library calls:

```
$ ltrace ./crackme
```

After entering any input (e.g., `test`), the output would include:

```
puts("You must enter a password to access this program!")
__isoc23_scanf(0x..., 0x..., ...)
strcmp("test", "NAKED_SNAKE")                     = -1
printf("wrong password, try again.\n> ")
```

`ltrace` directly shows us the two arguments to `strcmp`: our input `"test"` and the expected password `"NAKED_SNAKE"`. This is the fastest possible solve -- one command, no disassembly needed.

---

### Step 4: Static Analysis (IDA / Binary Ninja / Ghidra)

Now let us solve the same crackme purely through static analysis to understand the complete internal logic.

#### 4.1: Loading the Binary

Open the crackme in your disassembler/decompiler of choice (IDA Free, Binary Ninja Cloud, or Ghidra). The tool will auto-detect that it is a 64-bit ELF and begin analysis.

Navigate to the `main` function (since the binary is not stripped, it will be labeled by name).

#### 4.2: Understanding the Decompiled Code

The decompiler will produce pseudocode approximately equivalent to:

```c
int main() {
    int i;
    unsigned char composite_key;

    // Phase 1: Decrypt the password
    // XOR each byte of enc_msg with key (0x69)
    for (i = 0; i <= 10; i++) {
        enc_msg[i] = enc_msg[i] ^ key;
    }

    // Compute composite_key = multiplier ^ offset
    composite_key = (unsigned char)(multiplier ^ offset);

    // Prompt for password
    puts("You must enter a password to access this program!");
    char input[12];
    scanf("%s", input);

    // Phase 2: Password check loop
    while (strcmp(input, enc_msg) != 0) {
        printf("wrong password, try again.\n> ");
        scanf("%s", input);
    }

    // Phase 3: Decrypt and print the flag
    for (i = 0; i <= 22; i++) {
        flag[i] = flag[i] ^ (composite_key + i);
    }
    puts(flag);

    return 0;
}
```

#### 4.3: Extracting the Data

From the `.data` section (visible in the disassembler's hex view or via `objdump -s -j .data crackme`):

| **Variable** | **Address** | **Raw Bytes (Hex)** | **Value** |
|---|---|---|---|
| `multiplier` | `0x4040` | `BB 00 00 00` | `0xBB` (187) |
| `offset` | `0x4044` | `03 00 00 00` | `0x03` (3) |
| `enc_msg` | `0x4048` | `27 28 22 2C 2D 36 3A 27 28 22 2C 00` | Encrypted password (12 bytes) |
| `key` | `0x4054` | `69` | `0x69` (105) |
| `flag` | `0x4060` | `FE F5 FB FC C7 FE F7 EF 88 84 90 9C 81 8B 85 95 91 99 9E 82 83 83 B3` | Encrypted flag (23 bytes) |

#### 4.4: Decrypting the Password Manually

The first loop XORs each byte of `enc_msg` with `key` (`0x69`):

```
enc_msg[0]  = 0x27 ^ 0x69 = 0x4E = 'N'
enc_msg[1]  = 0x28 ^ 0x69 = 0x41 = 'A'
enc_msg[2]  = 0x22 ^ 0x69 = 0x4B = 'K'
enc_msg[3]  = 0x2C ^ 0x69 = 0x45 = 'E'
enc_msg[4]  = 0x2D ^ 0x69 = 0x44 = 'D'
enc_msg[5]  = 0x36 ^ 0x69 = 0x5F = '_'
enc_msg[6]  = 0x3A ^ 0x69 = 0x53 = 'S'
enc_msg[7]  = 0x27 ^ 0x69 = 0x4E = 'N'
enc_msg[8]  = 0x28 ^ 0x69 = 0x41 = 'A'
enc_msg[9]  = 0x22 ^ 0x69 = 0x4B = 'K'
enc_msg[10] = 0x2C ^ 0x69 = 0x45 = 'E'
```

**Decrypted password: `NAKED_SNAKE`**

#### 4.5: Decrypting the Flag Manually

First, compute the composite key:

```
composite_key = multiplier ^ offset = 0xBB ^ 0x03 = 0xB8 (184)
```

Then, the second loop decrypts each byte of `flag` by XORing with `(composite_key + i)`:

```
flag[0]  = 0xFE ^ (0xB8 + 0)  = 0xFE ^ 0xB8 = 0x46 = 'F'
flag[1]  = 0xF5 ^ (0xB8 + 1)  = 0xF5 ^ 0xB9 = 0x4C = 'L'
flag[2]  = 0xFB ^ (0xB8 + 2)  = 0xFB ^ 0xBA = 0x41 = 'A'
flag[3]  = 0xFC ^ (0xB8 + 3)  = 0xFC ^ 0xBB = 0x47 = 'G'
flag[4]  = 0xC7 ^ (0xB8 + 4)  = 0xC7 ^ 0xBC = 0x7B = '{'
flag[5]  = 0xFE ^ (0xB8 + 5)  = 0xFE ^ 0xBD = 0x43 = 'C'
flag[6]  = 0xF7 ^ (0xB8 + 6)  = 0xF7 ^ 0xBE = 0x49 = 'I'
flag[7]  = 0xEF ^ (0xB8 + 7)  = 0xEF ^ 0xBF = 0x50 = 'P'
flag[8]  = 0x88 ^ (0xB8 + 8)  = 0x88 ^ 0xC0 = 0x48 = 'H'
flag[9]  = 0x84 ^ (0xB8 + 9)  = 0x84 ^ 0xC1 = 0x45 = 'E'
flag[10] = 0x90 ^ (0xB8 + 10) = 0x90 ^ 0xC2 = 0x52 = 'R'
flag[11] = 0x9C ^ (0xB8 + 11) = 0x9C ^ 0xC3 = 0x5F = '_'
flag[12] = 0x81 ^ (0xB8 + 12) = 0x81 ^ 0xC4 = 0x45 = 'E'
flag[13] = 0x8B ^ (0xB8 + 13) = 0x8B ^ 0xC5 = 0x4E = 'N'
flag[14] = 0x85 ^ (0xB8 + 14) = 0x85 ^ 0xC6 = 0x43 = 'C'
flag[15] = 0x95 ^ (0xB8 + 15) = 0x95 ^ 0xC7 = 0x52 = 'R'
flag[16] = 0x91 ^ (0xB8 + 16) = 0x91 ^ 0xC8 = 0x59 = 'Y'
flag[17] = 0x99 ^ (0xB8 + 17) = 0x99 ^ 0xC9 = 0x50 = 'P'
flag[18] = 0x9E ^ (0xB8 + 18) = 0x9E ^ 0xCA = 0x54 = 'T'
flag[19] = 0x82 ^ (0xB8 + 19) = 0x82 ^ 0xCB = 0x49 = 'I'
flag[20] = 0x83 ^ (0xB8 + 20) = 0x83 ^ 0xCC = 0x4F = 'O'
flag[21] = 0x83 ^ (0xB8 + 21) = 0x83 ^ 0xCD = 0x4E = 'N'
flag[22] = 0xB3 ^ (0xB8 + 22) = 0xB3 ^ 0xCE = 0x7D = '}'
```

**Decrypted flag: `FLAG{CIPHER_ENCRYPTION}`**

#### 4.6: Summary of the Crackme's Logic

1. The program stores an **XOR-encrypted password** (`enc_msg`) and a **key** (`0x69`). At startup, it decrypts the password by XORing each byte with the key, producing `NAKED_SNAKE`.
2. It prompts the user for input and compares it against the decrypted password using `strcmp`. If it does not match, it loops and asks again.
3. Once the correct password is entered, it computes a **composite decryption key** by XORing `multiplier` (`0xBB`) with `offset` (`0x03`), yielding `0xB8`.
4. It decrypts the **flag** by XORing each byte of the encrypted flag with `(composite_key + index)`, producing `FLAG{CIPHER_ENCRYPTION}`.
5. It prints the flag and exits.

---

## Key Concepts Recap

| **Concept** | **Description** |
|---|---|
| **XOR Encryption** | A symmetric operation where `A ^ B = C` and `C ^ B = A`. Widely used in simple encryption schemes. Easily reversible. |
| **Calling Convention (x86-64 System V)** | Function arguments are passed in registers: `RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` (in that order). Return value goes in `RAX`. |
| **PIE (Position-Independent Executable)** | Addresses in the binary are relative. The actual addresses at runtime depend on where the OS loads the binary (ASLR). |
| **Stripped vs. Not Stripped** | A stripped binary has its symbol table removed, meaning function and variable names are gone. This makes reverse engineering harder. |
| **ELF Format** | The standard binary format on Linux. Contains sections like `.text` (code), `.data` (initialized data), `.rodata` (read-only data), `.bss` (uninitialized data). |

---

## Essential Assembly Instructions Reference

For those new to reading x86-64 assembly, here is a reference of the most commonly encountered instructions:

| **Instruction** | **Meaning** | **Example** |
|---|---|---|
| `mov dst, src` | Copy value from src to dst | `mov rax, rbx` (rax = rbx) |
| `push val` | Push value onto the stack | `push rbp` |
| `pop dst` | Pop value from stack into dst | `pop rbp` |
| `add dst, src` | Add src to dst | `add rax, 5` (rax += 5) |
| `sub dst, src` | Subtract src from dst | `sub rsp, 0x20` (allocate 32 bytes on stack) |
| `xor dst, src` | Bitwise XOR | `xor eax, eax` (set eax to 0) |
| `cmp a, b` | Compare a and b (sets flags) | `cmp eax, 0xa` |
| `test a, b` | Bitwise AND (sets flags, discards result) | `test eax, eax` (check if eax is zero) |
| `jmp addr` | Unconditional jump | `jmp 0x1234` |
| `je / jz` | Jump if equal / zero | After `cmp`: jump if the values were equal |
| `jne / jnz` | Jump if not equal / not zero | After `cmp`: jump if the values differ |
| `jbe / jle` | Jump if below-or-equal / less-or-equal | Unsigned / signed comparison |
| `call addr` | Call a function | `call strcmp@plt` |
| `ret` | Return from a function | Pops return address and jumps to it |
| `lea dst, [addr]` | Load effective address (computes address, does not dereference) | `lea rax, [rbp-0x14]` |
| `movzbl src, dst` | Move byte with zero-extension to 32-bit | Used when loading a single byte into a register |

---

## Resources

### Interactive Learning Platforms
- [pwn.college](https://pwn.college/) -- Free, university-level courses on reverse engineering, binary exploitation, and systems security. Highly structured with hands-on challenges. **Strongly recommended.**
- [Nightmare](https://guyinatuxedo.github.io/) -- A comprehensive, free course on binary exploitation and reverse engineering built around real CTF challenges.
- [crackmes.one](https://crackmes.one/) -- A community repository of crackme challenges sorted by difficulty. Excellent for practicing reverse engineering skills.
- [Microcorruption](https://microcorruption.com/) -- An embedded security CTF with a built-in debugger in the browser. Great for learning assembly and debugging.
- [Reversing.kr](http://reversing.kr/) -- A collection of reverse engineering challenges of varying difficulty.
- [pwn.college – Reverse Engineering Module](https://pwn.college/program-security/reverse-engineering/) -- Dedicated reverse engineering challenges from pwn.college's Program Security dojo.
- [pwn.college – Assembly Crash Course](https://pwn.college/cse466-f2022/assembly-crash-course) -- A hands-on crash course in x86-64 assembly from pwn.college (CSE 466).
- [Reverse-Engineering (mytechnotalent)](https://github.com/mytechnotalent/Reverse-Engineering) -- A comprehensive, free GitHub repository covering reverse engineering from beginner to advanced, across multiple architectures.

### Wargames
- [OverTheWire](https://overthewire.org/wargames/) -- Start with **Bandit** (Linux basics), then move to **Narnia** and **Behemoth** (binary exploitation).
- [RingZer0 CTF](https://ringzer0ctf.com/) -- Hundreds of challenges across many categories, including reverse engineering.
- [W3Challs](https://w3challs.com/) -- A variety of security challenges including reverse engineering.
- [Wargame Nexus](https://wargame.nexus/) -- An aggregated directory of wargames and hacking challenges across many categories.

### Video Courses and Playlists
- [LiveOverflow](https://www.youtube.com/c/LiveOverflow) -- Excellent YouTube channel covering binary exploitation, reverse engineering, and CTF walkthroughs with clear explanations.
- [John Hammond](https://www.youtube.com/c/JohnHammond010) -- CTF walkthroughs and cybersecurity tutorials, many involving reverse engineering.
- [0xinfection's Reversing Playlist](https://www.youtube.com/playlist?list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN) -- Focused playlist on reverse engineering fundamentals.
- [OpenSecurityTraining2](https://opensecuritytraining.info/) -- University-quality courses on x86/x64 architecture and reverse engineering. Free.

### Books
- *Reverse Engineering for Beginners* by Dennis Yurichev -- Free and comprehensive. Available at [beginners.re](https://beginners.re/).
- *Practical Malware Analysis* by Michael Sikorski and Andrew Honig -- The standard textbook for malware reverse engineering.
- *Hacking: The Art of Exploitation (2nd Edition)* by Jon Erickson -- Covers both reverse engineering and binary exploitation with hands-on examples.

### Documentation and References
- [x86 and amd64 Instruction Reference](https://www.felixcloutier.com/x86/) -- Searchable reference for every x86/x64 instruction.
- [System V AMD64 ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf) -- The calling convention specification for 64-bit Linux.
- [ELF Format Specification](https://refspecs.linuxfoundation.org/elf/elf.pdf) -- The full specification of the Executable and Linkable Format.
- [Binary Ninja Cloud](https://cloud.binary.ninja/bn/d9770d5a-2efb-40ea-82ed-e4ad58d044be?view=Disassembly&func=4198809&il=3&address=4198809) -- A shared Binary Ninja cloud disassembly session for collaborative analysis.

---

## Final Notes

Reverse engineering is a skill built through **practice, patience, and persistence**. Every binary you analyze teaches you something new. Start with simple crackmes, build your comfort with assembly and debuggers, and gradually work your way up to more complex targets.

The combination of static and dynamic analysis, supported by a solid understanding of the underlying architecture, is what separates an effective reverse engineer from someone who simply runs automated tools.

Keep practicing, keep learning, and approach every binary as a puzzle waiting to be solved.
